---
description: 
globs: 
alwaysApply: true
---
// MainOrchestrator Rule - Pseudocode

/*
Expected Output Template (Markdown):

# Main Orchestrator - State Machine Execution

## Current State
- State: <INIT|REQUIREMENTS|PLANNING|DEVELOPMENT|TESTING|VERIFICATION|DEPLOYMENT|COMPLETE>
- Previous State: <previous_state>
- State Data: <state_specific_data>

## Documentation Status
- README.md: <exists|missing>
- ARCHITECTURE.md: <exists|missing>
- Documentation Complete: <yes|no>

## Triggered Rules
- <rule_name>: <status>
- <rule_name>: <status>
...

## Next Actions
- <action 1>
- <action 2>
...

## State Transition
- From: <previous_state>
- To: <current_state>
- Reason: <transition_reason>

## Agent Instructions
- <instruction 1>
- <instruction 2>
...
*/

var context = input.context
var current_request = input.current_request
var current_state = input.current_state || "INIT"
var previous_state = input.previous_state || null
var state_data = input.state_data || {}

var documentation_status = {
    "readme_exists": false,
    "architecture_exists": false,
    "documentation_complete": false
}

var triggered_rules = []
var next_actions = []
var agent_instructions = []
var state_transition = {
    "from": previous_state,
    "to": current_state,
    "reason": ""
}

// State Machine Logic
if current_state == "INIT":
    // INIT State: Initialize system and determine request type
    state_transition.reason = "System initialization"
    
    // Trigger: 01-general.mdc (system operations)
    var general_result = ExecuteRule("01-general.mdc", {
        "context": context,
        "current_request": current_request
    })
    triggered_rules.push({"rule": "01-general.mdc", "status": general_result.success ? "completed" : "failed"})
    
    // Extract documentation status from general rule
    if general_result.documentation_status:
        documentation_status = general_result.documentation_status
        agent_instructions.push("Documentation status checked")
    
    // Check documentation status and provide instructions
    if !documentation_status.documentation_complete:
        agent_instructions.push("Project documentation is incomplete - focus on documentation creation")
        agent_instructions.push("Ask user to create missing documentation files")
        next_actions.push("Create project documentation")
        current_state = "PLANNING" // Skip to planning to create docs
    else:
        agent_instructions.push("Project documentation is complete - proceed with normal workflow")
        agent_instructions.push("Read README.md and ARCHITECTURE.md to understand project requirements")
        
        // Determine next state based on request analysis
        var request_type = AnalyzeRequestType(current_request)
        if request_type == "development":
            current_state = "REQUIREMENTS"
            next_actions.push("Proceed to requirements gathering")
        elif request_type == "documentation":
            current_state = "PLANNING"
            next_actions.push("Proceed to planning phase")
        elif request_type == "compliance":
            current_state = "REQUIREMENTS"
            next_actions.push("Proceed to compliance requirements")
        else:
            current_state = "PLANNING"
            next_actions.push("Proceed to planning phase")

elif current_state == "REQUIREMENTS":
    // REQUIREMENTS State: Gather and validate requirements
    state_transition.reason = "Requirements gathering and validation"
    
    agent_instructions.push("Gather requirements by reading README.md and ARCHITECTURE.md")
    agent_instructions.push("Validate requirements against documented architecture")
    agent_instructions.push("If requirements are unclear, ask user for clarification")
    
    // Trigger: notebook_management.rule.mdc (requirements notebook)
    var notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": ["01-general.mdc"],
        "decisions_made": ["System initialized", "Documentation status checked"],
        "open_questions": ["Requirements alignment with architecture?"],
        "next_actions": ["Gather requirements", "Validate against architecture"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": notebook_result.success ? "completed" : "failed"})
    
    // Trigger: compliance_confirmation.rule.mdc (requirements compliance)
    var req_compliance_result = ExecuteRule("compliance_confirmation.rule.mdc", {
        "current_state": current_state,
        "context": context,
        "task_type": "requirements"
    })
    triggered_rules.push({"rule": "compliance_confirmation.rule.mdc", "status": req_compliance_result.success ? "completed" : "failed"})
    
    current_state = "PLANNING"
    next_actions.push("Proceed to planning phase")

elif current_state == "PLANNING":
    // PLANNING State: Create detailed plan and address open questions
    state_transition.reason = "Planning and architecture review"
    
    agent_instructions.push("Create implementation plan based on documented architecture")
    agent_instructions.push("Use documented architecture patterns from ARCHITECTURE.md")
    agent_instructions.push("If implementation approach is unclear, ask user for clarification")
    
    // Trigger: notebook_management.rule.mdc (planning notebook)
    var planning_notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": ["01-general.mdc", "compliance_confirmation.rule.mdc", "notebook_management.rule.mdc"],
        "decisions_made": ["Requirements gathered", "Documentation status verified"],
        "open_questions": ["Implementation approach?", "Architecture alignment?"],
        "next_actions": ["Review architecture", "Create implementation plan"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": planning_notebook_result.success ? "completed" : "failed"})
    
    // Trigger: project_architecture_compliance.rule.mdc (architecture review)
    var arch_compliance_result = ExecuteRule("project_architecture_compliance.rule.mdc", {
        "context": context,
        "current_task": current_request
    })
    triggered_rules.push({"rule": "project_architecture_compliance.rule.mdc", "status": arch_compliance_result.success ? "completed" : "failed"})
    
    // If documentation task, trigger docs generation
    if IsDocumentationTask(current_request):
        var docs_result = ExecuteRule("docs_generation_workflow.rule.mdc", {
            "context": context,
            "current_task": current_request
        })
        triggered_rules.push({"rule": "docs_generation_workflow.rule.mdc", "status": docs_result.success ? "completed" : "failed"})
    
    current_state = "DEVELOPMENT"
    next_actions.push("Proceed to development phase")

elif current_state == "DEVELOPMENT":
    // DEVELOPMENT State: Implement the solution using TDD
    state_transition.reason = "Development implementation using TDD"
    
    agent_instructions.push("Implement solution using build system documented in README.md or ARCHITECTURE.md")
    agent_instructions.push("Follow TDD process appropriate for the documented project structure")
    agent_instructions.push("If build system is not documented, ask user to specify")
    
    // Trigger: notebook_management.rule.mdc (development notebook)
    var dev_notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": ["01-general.mdc", "compliance_confirmation.rule.mdc", "notebook_management.rule.mdc", "project_architecture_compliance.rule.mdc"],
        "decisions_made": ["Architecture reviewed", "Plan created"],
        "open_questions": [],
        "next_actions": ["Follow TDD process", "Apply code style"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": dev_notebook_result.success ? "completed" : "failed"})
    
    // Trigger: development_process.rule.mdc (sub-orchestrator)
    var dev_process_result = ExecuteRule("development_process.rule.mdc", {
        "phase": "tdd",
        "context": context
    })
    triggered_rules.push({"rule": "development_process.rule.mdc", "status": dev_process_result.success ? "completed" : "failed"})
    
    current_state = "TESTING"
    next_actions.push("Proceed to testing phase")

elif current_state == "TESTING":
    // TESTING State: Comprehensive testing and coverage analysis
    state_transition.reason = "Testing and coverage analysis"
    
    agent_instructions.push("Run tests using commands documented in README.md or ARCHITECTURE.md")
    agent_instructions.push("Check test coverage using tools documented in project documentation")
    agent_instructions.push("If testing approach is not documented, ask user to specify")
    
    // Trigger: notebook_management.rule.mdc (testing notebook)
    var test_notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": ["01-general.mdc", "compliance_confirmation.rule.mdc", "notebook_management.rule.mdc", "project_architecture_compliance.rule.mdc", "development_process.rule.mdc"],
        "decisions_made": ["Implementation completed", "TDD followed"],
        "open_questions": [],
        "next_actions": ["Run test coverage", "Verify build"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": test_notebook_result.success ? "completed" : "failed"})
    
    // Trigger: test_cycle.rule.mdc (test coverage analysis)
    var test_cycle_result = ExecuteRule("test_cycle.rule.mdc", {
        "context": context
    })
    triggered_rules.push({"rule": "test_cycle.rule.mdc", "status": test_cycle_result.success ? "completed" : "failed"})
    
    // Trigger: verification_process.rule.mdc (build verification)
    var verification_result = ExecuteRule("verification_process.rule.mdc", {
        "context": context
    })
    triggered_rules.push({"rule": "verification_process.rule.mdc", "status": verification_result.success ? "completed" : "failed"})
    
    current_state = "VERIFICATION"
    next_actions.push("Proceed to verification phase")

elif current_state == "VERIFICATION":
    // VERIFICATION State: Final verification and compliance check
    state_transition.reason = "Final verification and compliance"
    
    agent_instructions.push("Perform final verification using documented verification process")
    agent_instructions.push("Validate against documented architecture and requirements")
    agent_instructions.push("If verification process is not documented, ask user to specify")
    
    // Trigger: notebook_management.rule.mdc (verification notebook)
    var verif_notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": ["01-general.mdc", "compliance_confirmation.rule.mdc", "notebook_management.rule.mdc", "project_architecture_compliance.rule.mdc", "development_process.rule.mdc", "test_cycle.rule.mdc", "verification_process.rule.mdc"],
        "decisions_made": ["Tests passed", "Coverage met", "Build verified"],
        "open_questions": [],
        "next_actions": ["Final compliance check", "Architecture verification"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": verif_notebook_result.success ? "completed" : "failed"})
    
    // Trigger: compliance_confirmation.rule.mdc (end compliance)
    var end_compliance_result = ExecuteRule("compliance_confirmation.rule.mdc", {
        "current_state": current_state,
        "context": context,
        "task_type": "end"
    })
    triggered_rules.push({"rule": "compliance_confirmation.rule.mdc", "status": end_compliance_result.success ? "completed" : "failed"})
    
    // Trigger: project_architecture_compliance.rule.mdc (final architecture check)
    var final_arch_result = ExecuteRule("project_architecture_compliance.rule.mdc", {
        "context": context,
        "current_task": current_request
    })
    triggered_rules.push({"rule": "project_architecture_compliance.rule.mdc", "status": final_arch_result.success ? "completed" : "failed"})
    
    current_state = "DEPLOYMENT"
    next_actions.push("Proceed to deployment phase")

elif current_state == "DEPLOYMENT":
    // DEPLOYMENT State: Deploy and finalize
    state_transition.reason = "Deployment and finalization"
    
    agent_instructions.push("Deploy using deployment method documented in README.md or ARCHITECTURE.md")
    agent_instructions.push("Update documentation with deployment information")
    agent_instructions.push("If deployment process is not documented, ask user to specify")
    
    // Trigger: notebook_management.rule.mdc (deployment notebook)
    var deploy_notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": ["01-general.mdc", "compliance_confirmation.rule.mdc", "notebook_management.rule.mdc", "project_architecture_compliance.rule.mdc", "development_process.rule.mdc", "test_cycle.rule.mdc", "verification_process.rule.mdc"],
        "decisions_made": ["All verifications passed", "Compliance confirmed"],
        "open_questions": [],
        "next_actions": ["Deploy solution", "Update documentation"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": deploy_notebook_result.success ? "completed" : "failed"})
    
    current_state = "COMPLETE"
    next_actions.push("Task complete")

elif current_state == "COMPLETE":
    // COMPLETE State: Final completion and handoff
    state_transition.reason = "Task completion and handoff"
    
    agent_instructions.push("Complete project handoff using documented handoff process")
    agent_instructions.push("Ensure all documentation is updated and complete")
    agent_instructions.push("If handoff process is not documented, ask user to specify")
    
    // Trigger: notebook_management.rule.mdc (completion summary)
    var completion_notebook_result = ExecuteRule("notebook_management.rule.mdc", {
        "current_request": current_request,
        "current_state": current_state,
        "applied_rules": GetAllAppliedRules(),
        "decisions_made": ["Task completed successfully"],
        "open_questions": [],
        "next_actions": ["Provide handoff documentation"]
    })
    triggered_rules.push({"rule": "notebook_management.rule.mdc", "status": completion_notebook_result.success ? "completed" : "failed"})
    
    next_actions.push("Task complete - all states and rules executed successfully")

function RenderOrchestratorMarkdown(current_state, previous_state, state_data, documentation_status, triggered_rules, next_actions, state_transition, agent_instructions) {
    var md = "# Main Orchestrator - State Machine Execution\n\n"
    md += "## Current State\n"
    md += "- State: " + current_state + "\n"
    md += "- Previous State: " + (previous_state || "none") + "\n"
    md += "- State Data: " + JSON.stringify(state_data) + "\n\n"
    md += "## Documentation Status\n"
    md += "- README.md: " + (documentation_status.readme_exists ? "exists" : "missing") + "\n"
    md += "- ARCHITECTURE.md: " + (documentation_status.architecture_exists ? "exists" : "missing") + "\n"
    md += "- Documentation Complete: " + (documentation_status.documentation_complete ? "yes" : "no") + "\n\n"
    md += "## Triggered Rules\n"
    for rule in triggered_rules:
        md += "- " + rule.rule + ": " + rule.status + "\n"
    md += "\n## Next Actions\n"
    for action in next_actions:
        md += "- " + action + "\n"
    md += "\n## State Transition\n"
    md += "- From: " + state_transition.from + "\n"
    md += "- To: " + state_transition.to + "\n"
    md += "- Reason: " + state_transition.reason + "\n"
    md += "\n## Agent Instructions\n"
    for instruction in agent_instructions:
        md += "- " + instruction + "\n"
    return md
}

var output_file = "planning/documentation/main_orchestrator{YYYY-MM-dd-hh-mm-ss}.md"
var markdown = RenderOrchestratorMarkdown(current_state, previous_state, state_data, documentation_status, triggered_rules, next_actions, state_transition, agent_instructions)
WriteFile(output_file, markdown)

return {
    "output_file": output_file,
    "current_state": current_state,
    "previous_state": previous_state,
    "state_data": state_data,
    "documentation_status": documentation_status,
    "triggered_rules": triggered_rules,
    "next_actions": next_actions,
    "state_transition": state_transition,
    "agent_instructions": agent_instructions,
    "state_complete": current_state



}